C语言：f()可以有任意参数，f(void)不支持有参数

C++：f()、f(void)都不支持有参数

c++ const int 真实常量，值不能改  const int a; int array[a] = {0};正确

c const int 只读变量，值可以改  const int a; int array[a] = {0}; 错误

const有作用域、有类型检查

bool:true1、false0，可做加减乘除与或非

三目运算符：当左支用需全变量且返回一个变量的引用（有常量不能当左支）

​			C语言中不能做左支

引用：（新的别名）本质：指针int*const

1. 声明变量引用必须初始化

   int a = 5;

   int &b = a;//起小名

2. 变量类型必须相同

3. 引用作为参数时可以不用初始化

   swap(int *a, int *b); swap(&a, &b);

   swap(int &a, int &b); swap(a, b); //不需要初始化原因：传参函数内初始化

   void swap(int &a, int &b) {

   ​	int temp = a;

   ​	a = b;

   ​	b = temp;

   }

4. 局部变量不能当引用返回来

c语言中函数参数不能有默认值

c++中函数可以有默认值，但规定如果添加默认值，要从右往左添加，声明时给默认值，实现时不需要给默认值，调用时从左往右匹配

函数占位参数：只有类型，没有形参

函数重载：只与函数名、参数列表有关，与返回值无关

​		   同一作用域，函数名相同，参数列表（参数类型、参数个数、多种参数类型的参数顺序）不同

​		   本质是不同的函数：地址不同

​		   C语言不允许函数重载

函数重载+函数指针：

1. 参数个数和参数类型必须相同（指针）
2. 返回值类型必须相同（C++强类型语言）

函数重载+参数默认值 编译器调用准则：（防止二义性产生）

1. 所有重载函数都作为被选对象

2. 编译器尝试寻找匹配的函数（精确匹配参数）

3. 例：f(int x = 1, int y = 2)

   ​        f()

动态内存分配：new/delete（关键字）

public公共访问权限

private私有访问权限

全局变量没有初始化，值为0

栈区、堆区没有初始化，值为随机值

**构造函数**：

1. 没有返回值类型
2. 函数名必须与类名相同
3. 定义对象时自动调用
4. 可以重载

当类中没有构造函数时，编译器默认提供一个无参的构造函数，函数体是空（有构造函数则不提供）

**浅拷贝**：拷贝之后物理状态相同（相同的地址，相同的值）

**深拷贝**：拷贝之后逻辑状态相同（不同的地址，相同的值）

手动实现构造函数，必须实现深拷贝

**构造函数的初始化列表**：

1. 类中的属性可以用const修饰，普通的初始化方法不好使，这是就需要初始化列表
2. 必须使用初始化列表的初始化：
   1. const成员属性：only read、真正常量
   2. 类属性：空类、类里有带参构造时
   3. 注意事项：
      1. 初始化列表初始化顺序与成员属性声明顺序相同
      2. 初始化顺序与初始化列表中位置无关
      3. 初始化列表优先于函数体执行

**析构函数**：无参数、无返回值、不可被重载、一个类中只可以有一个析构函数

对象的构造顺序影响结果

堆上new调用构造函数，delete调用析构函数

尽量不要使用全局变量，原因：C++标准中没有规定全局对象构造顺序，不同编译器结果不同

对象构造顺序：先父母（父类）再朋友（private:value v1;value v2;）再自己（调自己的构造函数）

对象析构顺序：与构造顺序相反

**类属性与方法**

统计类创建对象的个数并保证安全性

静态成员变量：static int cnt；

1. 属于整个类
2. 生命周期是整个程序
3. 可以通过类名直接访问公有的静态成员变量（静态成员变量有访问级别）
4. 所有对象都共享

静态成员方法：静态成员函数不能直接访问普通的成员变量，只能访问静态成员变量

|                | 静态成员变量 | 普通成员变量 |
| :------------: | :----------: | :----------: |
| 所有对象都共享 |      +       |      +       |
|  隐藏this指针  |      -       |      +       |
|  访问普通成员  |      -       |      +       |
|  访问静态成员  |      +       |      +       |
|  通过类名调用  |      +       |      -       |
| 通过对象名调用 |      +       |      +       |

对象在内存中，属性是自己的，不共享的，方法是大家的，共享的

每个成员方法中都有this指针，this指针是某个对象地址，静态成员函数没有this指针

**const方法**：类外：type classname::funcname() const {} 类内：type funcname() const {}

1. const对象只能调用const方法
2. const成员函数内部只能调用const方法
3. const方法中变量值不能更改

struct访问权限默认为public

class访问权限默认为private

临时对象的生命周期只有当前行

组合关系特点：

1. 类对象作为当前？？？
2. 其他类对象生命周期与当前类对象相同
3. ？？？

**继承**：类与类的一种关系、单向关系

用法：

class A()

class B : 继承方式：public、private、protect

父类也叫基类，派生类也叫子类

特点：

1. 子类继承父亲的所有属性和方法
2. 子类是一种特殊的父类
3. 子类对象可以当父类对象用
4. 子类可以添加自己的属性和方法，还可以重写父类中的方法

继承的构造与析构顺序

1. 默认构造方式：要求父类的构造方式必须是**无参**的或者带**默认参数**的构造函数
2. 构造顺序：先自动或手动调用父类构造函数（必须有匹配的），再调用子类构造函数
3. 析构顺序：与构造顺序相反

子类构造：

1. 子类对象构造时，需要先初始化父类各属性，需要调用父类构造函数
2. 构造函数执行顺序：先父类，后朋友（组合关系），再自己
3. 父类构造函数显式调用时，必须在子类构造函数初始化列表中
4. 子类对象销毁时，同样需要调用父类析构函数（自动调用）
5. 先构造的后析构

父子间可以定义相同名字的属性和方法

**父子间重名冲突**：当子类与父类定义了相同名字的属性和方法，优先使用新定义的方法或属性，自动把父类的同名属性和方法隐藏（使用作用域分辨符使用被隐藏的父类同名属性或方法）

子类和父类中同名方法不构成重载关系，叫做重写关系（父类与子类属于两个作用域）

使用作用域分辨符访问同名成员属性和方法

父子间容：

1. 子类是特殊的父类
2. 子类对象可以初始化父类对象
3. 父类对象指针可以指向子类对象　A *p = &b;
4. 父类对象可以引用子类对象　A &p = b;

编译器根据指针判断，解释为父类的对象是最安全的，多态：virtual

一个对象是一种特殊的结构体，运行时退化成结构体

1. 成员属性是依次排列的
2. 成员属性之间可能存在内存空隙
3. 可以通过内存地址直接访问
4. 访问权限只在编译期有效，运行期无效

多继承带来数据冗余的问题，虚继承解决

首先要在最底层子类构造函数中显式相同最顶层父类构造函数

多态：不同对象产生不同行为

多态根据实际对象去判断调用重写函数

父类指针指向父类对象时，调用父类对象函数；指向子类对象时，调用重写父类中同名函数

支持多态的关键字virtual：

1. 声明多态
2. 　　
3. 　　

多态意义：

1. 在程序中表现出多态特性
2. 在子类中重写的父类同名函数必须声明成虚函数，否则没有意义
3. 多态是面向对象设计基础

静态联编：程序在编译期间就知道调用哪个函数，函数重载

动态联编：程序在运行期间才知道调用哪个函数，函数重写

实现多态原理：virtual -> 对象大小改变 -> 虚函数指针指向虚函数表将虚函数存到虚函数表中

多态原理：

1. 在类声明虚函数时，编译器会自动生成一个虚函数表
2. 虚函数是一个存储成员函数地址的数据结构
3. 虚函数表是编译器自动生成和维护的
4. 被virtual修饰的虚函数会被收入虚函数表中
5. 存在虚函数时，每个对象会有一个指针指向虚函数表，指针在对象头部

函数重写只能发生在父类与子类之间

多态是指根据对象的具体类型调用具体的函数

C++中virtual是支持多态的唯一方式

被重写的函数具有多态性

纯虚函数：virtual　只有声明函数原型的成员函数　class A {public: **virtual say() = 0**;}

一个类中含有纯虚函数就是抽象类

抽象类用来表示抽象概念，没有对象，只能当做父类

抽象类特性:

1. 只能定义类型不能产生对象
2. 只能被继承，并重写相关函数
3. 某些相关函数（纯虚函数）没有被实现

C++中没有真正的抽象类概念，只能通过纯虚函数间接实现

接口：特殊的抽象类，一组函数原型，C++中没有直接接口概念，抽象类模拟接口

1. 抽象类中没有任何成员变量
2. 所有成员函数都是公有的
3. 所有成员函数都是纯虚函数

**泛型编程**

宏优点：少；缺点：不安全

全局重载函数优点：被编译过；缺点：写的太多了

又少又被编译过：函数模板

**函数模板**：一种泛型编程方式，不考虑具体数据类型的一种编程方式

template \<typename T>

template开始模板编程，声明泛型编程

typename声明泛指类型、告诉编译器T就是泛指类型

模板的意义：

1. c++中泛型编程应用方式之一
2. 函数模板能够根据实参类型进行参数类型推导
3. 函数模板支持显示指定参数类型
4. 函数模板是C++中代码复用的一种方式

自动推导实参参数类型

显式指定实参参数类型

函数模板使用注意事项：

1. 函数模板本身不支持类型的隐式转化
2. 在自动推导类型时，必须严格遵循类型匹配，而且不会进行隐式类型转换
3. 显示指定类型时，能够进行隐式类型转换

template \<typename T>

template \<typename T1, typename T2...>

多个类型参数时，返回值类型无法自动推导，必须手动给出；可以**从左至右**给出部分实参类型；返回值类型也是模板参数时一般写在第一个

顺序：普通函数->模板函数->变参函数

如何判断：普通变量？指针变量？

普通函数和模板函数可以构成重载关系

**类模板**：不用管数据类型对数据进行操作

声明一个类模板：

template \<typename T>

class classname {

​	private:

​		T a;

​	public:

​		T get(){

​			

​		}

};

1. 当在类外实现成员函数时，template \<typename T> 返回值　classname\<i>::add(){}
2. 类模板声明和实现在同个头文件中

多参数类模板

特化只是类模板的分开实现

类模板可以有多个类型参数

特化的类模板使用方法都一样，必须显式指定参数的类型

有多个特化的模板根据不同的参数类型选择不同的特化

函数模板也支持特化，只支持完全特化

完全特化：完全显式指定出类型参数

template <>

class Test<int, int> {};

部分特化：用特定规则去约束类型参数

模板的来源：泛型编程：数据类型与对数据的操作分开

C++中只有模板函数和模板类支持泛型编程

模板的用法：

1. template：告诉编译器我要模板编程了
2. \<typename T> T参数列表

函数模板可以是数值类型的参数

template \<typename T, int N>

void func() {

​	T a[N];

}

func<double, 10>();

使用注意事项：数值类型的参数不能用变量、浮点类型、类类型

**异常处理**

异常：程序中可预期的分支执行

1. a/b (b == 0)：程序异常停止
2. 数组访问越界
3. 打开文件不存在（fopen）

Bug：程序中不可预期的执行

1. 堆空间申请未释放：内存泄露
2. 野指针
3. 排序0长度的数组

C语言中异常处理方式：if (非异常情况) {正常处理} else {异常处理}

C++中异常处理方式：

1. throw：抛出异常：整型、字符、字符串、类类型
2. try {正确代码} catch () {异常处理}：自上而下严格匹配异常类型、匹配时不进行类型转换
   1. try后可以跟多个catch
   2. catch语句块中可以定义具体异常类型
   3. 不同类型的异常可以用不同catch去处理
   4. catch(...)表示可以处理任意类型的异常并且只能放在最后
   5. 任意一种类型的异常只能被捕获一次

异常可以是自定义类型的

同样遵循自上而下的严格匹配

父子间容依然适用，一般性原则匹配子类异常放在父类异常前

**友元**：

1. 在类中，某个函数前用friend修饰
2. 友元函数不是类的一部分
3. 友元函数不受类中访问权限限制
4. 友元函数能访问类中所有一切属性

友元函数

友元类

**操作符重载（运算符重载）**

1. 通过函数重载去扩展系统操作符功能
2. 操作符重载是以函数方式进行的
3. 本质：是一种特殊的函数，通过函数扩展原有操作符功能
4. 关键字operator+、operator-、operator*、operator/......
5. 操作符重载可以重载成全局函数（两个操作数）成员函数（this指针代替左操作数）
6. 有些操作符只能重载成成员函数
7. 操作符重载不能改变原有运算符优先级
8. 不能改变原运算符操作数个数
9. 不能改变原运算符原生语义（=返回左值的引用）

**赋值重载**：浅拷贝->系统；深拷贝->必须重载

1. 判断自赋值
2. 深拷贝
3. 返回左值

**取地址符[]重载**：

1. 只能重载成成员函数
2. 重载函数只能有一个参数
3. 参数类型可以不同

**函数调用运算符()重载**：

1. 只能重载成成员函数
2. 可以定义多个不同参数的多个重载函数
3. 对象代替函数
4. 当前对象具备了函数行为

**智能指针特性**

1. 能自动回收堆空间
2. 一片内存空间只能有一个指针指向（避免多次释放）
3. 杜绝指针运算
4. 用对象模拟原生指针

**->和*重载注意事项**

1. 只能重载成成员函数
2. 重载函数不能有参数
3. 一个类中只能定义一个重载函数

**逻辑运算符不适合重载**：原因：操作符重载本质是函数调用，满足不了逻辑运算符的最短路原则

