C语言：f()可以有任意参数，f(void)不支持有参数

C++：f()、f(void)都不支持有参数

c++ const int 真实常量，值不能改  const int a; int array[a] = {0};正确

c const int 只读变量，值可以改  const int a; int array[a] = {0}; 错误

const有作用域、有类型检查

bool:true1、false0，可做加减乘除与或非

三目运算符：当左支用需全变量且返回一个变量的引用（有常量不能当左支）

​			C语言中不能做左支

引用：（新的别名）本质：指针int*const

1. 声明变量引用必须初始化

   int a = 5;

   int &b = a;//起小名

2. 变量类型必须相同

3. 引用作为参数时可以不用初始化

   swap(int *a, int *b); swap(&a, &b);

   swap(int &a, int &b); swap(a, b); //不需要初始化原因：传参函数内初始化

   void swap(int &a, int &b) {

   ​	int temp = a;

   ​	a = b;

   ​	b = temp;

   }

4. 局部变量不能当引用返回来

c语言中函数参数不能有默认值

c++中函数可以有默认值，但规定如果添加默认值，要从右往左添加，声明时给默认值，实现时不需要给默认值，调用时从左往右匹配

函数占位参数：只有类型，没有形参

函数重载：只与函数名、参数列表有关，与返回值无关

​		   同一作用域，函数名相同，参数列表（参数类型、参数个数、多种参数类型的参数顺序）不同

​		   本质是不同的函数：地址不同

​		   C语言不允许函数重载

函数重载+函数指针：

1. 参数个数和参数类型必须相同（指针）
2. 返回值类型必须相同（C++强类型语言）

函数重载+参数默认值 编译器调用准则：（防止二义性产生）

1. 所有重载函数都作为被选对象

2. 编译器尝试寻找匹配的函数（精确匹配参数）

3. 例：f(int x = 1, int y = 2)

   ​        f()

动态内存分配：new/delete（关键字）

public公共访问权限

private私有访问权限

全局变量没有初始化，值为0

栈区、堆区没有初始化，值为随机值

**构造函数**：

1. 没有返回值类型
2. 函数名必须与类名相同
3. 定义对象时自动调用
4. 可以重载

当类中没有构造函数时，编译器默认提供一个无参的构造函数，函数体是空（有构造函数则不提供）

**浅拷贝**：拷贝之后物理状态相同（相同的地址，相同的值）

**深拷贝**：拷贝之后逻辑状态相同（不同的地址，相同的值）

手动实现构造函数，必须实现深拷贝

**构造函数的初始化列表**：

1. 类中的属性可以用const修饰，普通的初始化方法不好使，这是就需要初始化列表
2. 必须使用初始化列表的初始化：
   1. const成员属性：only read、真正常量
   2. 类属性：空类、类里有带参构造时
   3. 注意事项：
      1. 初始化列表初始化顺序与成员属性声明顺序相同
      2. 初始化顺序与初始化列表中位置无关
      3. 初始化列表优先于函数体执行

**析构函数**：无参数、无返回值、不可被重载、一个类中只可以有一个析构函数

对象的构造顺序影响结果

堆上new调用构造函数，delete调用析构函数

尽量不要使用全局变量，原因：C++标准中没有规定全局对象构造顺序，不同编译器结果不同

对象构造顺序：先父母（父类）再朋友（private:value v1;value v2;）再自己（调自己的构造函数）

对象析构顺序：与构造顺序相反

**类属性与方法**

统计类创建对象的个数并保证安全性

静态成员变量：static int cnt；

1. 属于整个类
2. 生命周期是整个程序
3. 可以通过类名直接访问公有的静态成员变量（静态成员变量有访问级别）
4. 所有对象都共享

静态成员方法：静态成员函数不能直接访问普通的成员变量，只能访问静态成员变量

|                | 静态成员变量 | 普通成员变量 |
| :------------: | :----------: | :----------: |
| 所有对象都共享 |      +       |      +       |
|  隐藏this指针  |      -       |      +       |
|  访问普通成员  |      -       |      +       |
|  访问静态成员  |      +       |      +       |
|  通过类名调用  |      +       |      -       |
| 通过对象名调用 |      +       |      +       |

对象在内存中，属性是自己的，不共享的，方法是大家的，共享的

每个成员方法中都有this指针，this指针是某个对象地址，静态成员函数没有this指针

**const方法**：类外：type classname::funcname() const {} 类内：type funcname() const {}

1. const对象只能调用const方法
2. const成员函数内部只能调用const方法
3. const方法中变量值不能更改



