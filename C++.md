C语言：f()可以有任意参数，f(void)不支持有参数

C++：f()、f(void)都不支持有参数

c++ const int 真实常量，值不能改  const int a; int array[a] = {0};正确

c const int 只读变量，值可以改  const int a; int array[a] = {0}; 错误

const有作用域、有类型检查

bool:true1、false0，可做加减乘除与或非

三目运算符：当左支用需全变量且返回一个变量的引用（有常量不能当左支）

​			C语言中不能做左支

引用：（新的别名）本质：指针int*const

1. 声明变量引用必须初始化

   int a = 5;

   int &b = a;//起小名

2. 变量类型必须相同

3. 引用作为参数时可以不用初始化

   swap(int *a, int *b); swap(&a, &b);

   swap(int &a, int &b); swap(a, b); //不需要初始化原因：传参函数内初始化

   void swap(int &a, int &b) {

   ​	int temp = a;

   ​	a = b;

   ​	b = temp;

   }

4. 局部变量不能当引用返回来

c语言中函数参数不能有默认值

c++中函数可以有默认值，但规定如果添加默认值，要从右往左添加，声明时给默认值，实现时不需要给默认值，调用时从左往右匹配

函数占位参数：只有类型，没有形参

函数重载：只与函数名、参数列表有关，与返回值无关

​		   同一作用域，函数名相同，参数列表（参数类型、参数个数、多种参数类型的参数顺序）不同

​		   本质是不同的函数：地址不同

​		   C语言不允许函数重载

函数重载+函数指针：

1. 参数个数和参数类型必须相同（指针）
2. 返回值类型必须相同（C++强类型语言）

函数重载+参数默认值 编译器调用准则：（防止二义性产生）

1. 所有重载函数都作为被选对象

2. 编译器尝试寻找匹配的函数（精确匹配参数）

3. 例：f(int x = 1, int y = 2)

   ​        f()

动态内存分配：new/delete（关键字）

public公共访问权限

private私有访问权限

全局变量没有初始化，值为0

栈区、堆区没有初始化，值为随机值

构造函数：

1. 没有返回值类型
2. 函数名必须与类名相同
3. 定义对象时自动调用
4. 可以重载

当类中没有构造函数时，编译器默认提供一个无参的构造函数，函数体是空（有构造函数则不提供）

浅拷贝：拷贝之后物理状态相同（相同的地址，相同的值）

深拷贝：拷贝之后逻辑状态相同（不同的地址，相同的值）

手动实现构造函数，必须实现深拷贝